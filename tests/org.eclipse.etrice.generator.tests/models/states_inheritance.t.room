RoomModel states_inheritance.t {

	import room.basic.service.timing.*

	ProtocolClass PTest1 {
		incoming {
			Message a ()
			Message b (x : int32)
			Message c ()
		}
		outgoing {
			Message x ()
		}
	}

	ProtocolClass PTest2 {
		incoming {
			Message x ()
			Message y ()
			Message z ()
		}
		outgoing {
			Message a ()
		}
	}

	ProtocolClass PTest3 {
		incoming {
			Message a ()
		}
		outgoing {
			Message b ()
		}
	}

	LogicalSystem SystemMain {
		SubSystemRef subsystem : SubSystemMain
	}

	SubSystemClass SubSystemMain {
		ActorRef application : App_SubSystemMain
		ActorRef services : ATimingService

		LayerConnection ref application satisfied_by services.timer
		LayerConnection ref application satisfied_by services.timeout
	}

	// automatically inserted App_SubSystemMain
	ActorClass App_SubSystemMain {
		Structure {
			ActorRef derived : ADerived
		}
	}

	abstract ActorClass ATest {
		Interface {
			Port fct : PTest1
		}
		Structure {
			external Port fct
			Port sub : PTest2
			SAP timer: PTimer
			SAP timeout: PTimeout
		}
		Behavior {
			StateMachine {
				State State1 {}
				State State2 {
					subgraph {
						EntryPoint tp0
						EntryPoint tp1
						EntryPoint tp2
						EntryPoint tp3
						ExitPoint tp4
					}
				}
				State State3 {
					subgraph {
						State State1 {}
						State State2 {}
						State State3 {}
						EntryPoint tp0
						EntryPoint tp1
						TransitionPoint tp2
						ExitPoint tp3
						ExitPoint tp4
						handler TransitionPoint tp5
						Transition tr0: initial -> State1 {}
						Transition tr1: my tp1 -> State3 {}
						Transition tr2: State1 -> State2 {
							triggers {
								<b:fct>
							}
						}
						Transition tr3: State2 -> State3 {
							triggers {
								<c:fct>
							}
						}
						Transition tr4: State3 -> State1 {
							triggers {
								<a:fct>
							}
						}
						Transition tr5: my tp2 -> State3 {
							triggers {
								<b:fct>
							}
						}
						Transition tr6: State3 -> my tp3 {
							triggers {
								<c:fct>
							}
						}
						Transition tr7: my tp5 -> my tp5 {
							triggers {
								<timeoutTick:timeout>
							}
						}
					}
				}
				State State4 {
					subgraph {
						EntryPoint tp0
					}
				}
				TransitionPoint tp0
				TransitionPoint tp1
				ChoicePoint CP1
				Transition tr0: initial -> State1 {}
				Transition tr1: State1 -> tp0 of State2 {
					triggers {
						<a:fct>
					}
				}
				Transition tr2: tp4 of State2 -> cp CP1 {
					triggers {
						<b:fct>
					}
				}
				Transition tr3: cp CP1 -> State1 {}
				Transition tr4: cp CP1 -> tp0 of State3 {
					cond {
						"data==2"
					}
				}
				Transition tr5: my tp0 -> tp1 of State3 {
					triggers {
						<a:fct>
					}
				}
				Transition tr6: cp CP1 -> tp0 of State4 {
					cond {
						"data==3"
					}
				}
				Transition tr7: tp3 of State3 -> tp1 of State2 {}
				Transition tr8: tp4 of State3 -> tp2 of State2 {
					triggers {
						<c:fct>
					}
				}
				Transition tr9: my tp1 -> tp3 of State2 {
					triggers {
						<timerTick:timer>
					}
				}
			}
		}
	}

	ActorClass ADerived extends ATest {
		Interface {
			Port port : PTest3
		}
		Structure {
			external Port port
		}
		Behavior {
			StateMachine {
				RefinedState State2 {
					subgraph {
						State Intermediate {}
						Transition tr0: my tp0 -> Intermediate {}
						Transition tr1: Intermediate -> my tp1 {
							triggers {
								<x:sub>
							}
						}
						Transition tr2: initial -> Intermediate {}
					}
				}
				RefinedState State3 {
					subgraph {
						State State4 {}
						EntryPoint tp6
						TransitionPoint tp7
						Transition tr8: my tp6 -> State2 {}
						Transition tr9: my tp7 -> my tp7 {
							triggers {
								<z:sub>
							}
						}
						Transition tr10: State2 -> State4 {
							triggers {
								<y:sub>
							}
						}
						Transition tr11: State4 -> my tp3 {
							triggers {
								<z:sub>
							}
						}
						Transition tr12: State2 -> my tp4 {
							triggers {
								<a:port>
							}
						}
					}
				}
				RefinedState State4 {
					subgraph {
						State State1 {}
						State State2 {}
						Transition tr0: initial -> State1 {}
						Transition tr1: State1 -> State2 {
							triggers {
								<a:port>
							}
						}
					}
				}
				State State5 {}
				Transition tr10: State1 -> State5 {
					triggers {
						<a:port>
					}
				}
				Transition tr11: cp CP1 -> State5 {
					cond {
						"data==4"
					}
				}
				Transition tr12: State5 -> tp6 of State3 {
					triggers {
						<a:port>
					}
				}
			}
		}
	}

}
